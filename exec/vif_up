#!/usr/bin/python
# VSYS script to configure per-slice virtual network interfaces from the root slice
#   Thom Haddow - 06/10/09
#
# Gets slice name as argv[1]
# Takes remaining args on stdin:
#   - Interface name (eg [tun|tap]<sliceid>-<n>)
#   - IP address (eg 1.2.3.4)
#   - Netmask (as int, e.g. 24)
#   - Followed by options as name=value pairs

import sys
import pwd
import re
import socket
import struct
import os
import string

vsys_config_dir = "/etc/planetlab/vsys-attributes"

if len(sys.argv) != 2: sys.exit(1)

# VSYS scripts get slicename as $1
slicename=sys.argv[1]
sliceid = pwd.getpwnam(slicename).pw_uid

netblock_config=os.path.join(vsys_config_dir,slicename,"vsys_vnet")

# Read netblock allocation file
base = None

for netblock in open(netblock_config,'r'):
    base, mask = netblock.split('/')

if base is None:
    print >>sys.stderr, "Could not find entry for slice %s in netblock config file %s" % (slicename, netblock_config)
    sys.exit(1)


### Read args from stdin
arglines = map(string.strip, sys.stdin.readlines())

if len(arglines)<3:
    print >>sys.stderr, "Insufficient argument lines."
    sys.exit(1)

vif = arglines[0] # interface name
vip = arglines[1] # IP
vmask = int(arglines[2]) # netmask as int

# Create options list
if len(arglines)>3:
    options = arglines[3:]
else:
    options = []

# Convert network base addr to int format by unpacking as 32bit net-ordered long (!L)
base_int = struct.unpack('!L',socket.inet_aton(base))[0]
mask = int(mask)


### Validate args
# Validate interface name
if len(vif)>16:
    print >>sys.stderr, "Interface name %s invalid"%(vif)
    sys.exit(1)

if re.match(r'(tun|tap)%d-\d+' % sliceid, vif ) is None:
    print >>sys.stderr, "Interface name %s does not match slice id %d."%(vif, sliceid)
    sys.exit(1)



# Validate requested IP and convert to int format.
try:
    vip_int = struct.unpack('!L',socket.inet_aton(vip))[0]
except socket.error:
    print >>sys.stderr, "Invalid IP: %s" % vip
    sys.exit(1)

# Check IP is in netblock
if (vip_int>>(32-mask)) != (base_int>>(32-mask)):
    print >>sys.stderr, "Requested IP %s not in netblock %s/%d" % (vip,base,mask)
    sys.exit(1)

# TODO. Check IP is not in use?

# Validate mask: Check requested mask is sane and within our netblock
if vmask>32 or vmask <8:
    print >>sys.stderr, "Requested netmask /%d is invalid" %(vmask)
    sys.exit(1)
    
if vmask<mask:
    print >>sys.stderr, "Requested netmask /%d larger than allocation /%d" %(vmask, mask)
    sys.exit(1)



### Process options

opt_txqueuelen = None
opt_rp_filter = None
opt_snat = None
opt_ovs_dp = None


for optionline in options:
    if len(optionline)==0: continue
    try:
        opt, val = optionline.split('=')
    except:
        print >>sys.stderr, "Bad option line: \"%s\"" % (optionline)
        sys.exit(1)

    if opt=="rp_filter":
        if val=="0":
            opt_rp_filter="0"
        elif val=="1":
            opt_rp_filter="1"
        else:
            print >>sys.stderr, "rp_filter value invalid: \"%s\"" % (val)
            sys.exit(1)

    elif opt=="txqueuelen":
        intval = int(val)
        if intval<1 or intval>10000:
            print >>sys.stderr, "txqueuelen value %s out of range 1-10000" % (val)
            sys.exit(1)
        opt_txqueuelen = intval
    elif opt=="snat":
	intval = int(val)
	if val=="1":
	  opt_snat = True
    elif opt=="vswitch":
	opt_ovs_dp = val
    else:
        print >>sys.stderr, "Unknown option: \"%s\"" % (opt)
        sys.exit(1)


### Configure interface

if opt_txqueuelen is None:
    cmd_ifconfig = "/sbin/ifconfig %s %s/%d" % (vif, vip, vmask)
else:
    cmd_ifconfig = "/sbin/ifconfig %s %s/%d txqueuelen %d" % (vif, vip, vmask, opt_txqueuelen)

os.system(cmd_ifconfig)

# Add iptables rules (Clearing old ones first, if they exist)
cmd_iptables_in = "/sbin/iptables -A INPUT -i %s -m mark -m state --state NEW ! --mark %d -j DROP" % (vif, sliceid)
cmd_iptables_del_in = "/sbin/iptables -D INPUT -i %s -m mark -m state --state NEW ! --mark %d -j DROP 2>/dev/null" % (vif, sliceid)
cmd_iptables_out = "/sbin/iptables -A OUTPUT -o %s -m state --state NEW -m mark ! --mark %d -j DROP" % (vif, sliceid)
cmd_iptables_del_out = "/sbin/iptables -D OUTPUT -o %s -m state --state NEW -m mark ! --mark %d -j DROP 2>/dev/null" % (vif, sliceid)

public_src = os.popen("ip route get 1.1.1.1 | head -1 | awk '{print $7;}'").read().rstrip();
cmd_iptables_pr = "/sbin/iptables -t nat -A POSTROUTING -s %s/%d -j SNAT --to-source %s --random" % (vip, vmask, public_src)
cmd_iptables_del_pr = "/sbin/iptables -t nat -D POSTROUTING -s %s/%d -j SNAT --to-source %s --random" % (vip, vmask, public_src)

os.system(cmd_iptables_del_in)
os.system(cmd_iptables_in)
os.system(cmd_iptables_del_out)
os.system(cmd_iptables_out)

if (opt_snat):
    os.system(cmd_iptables_del_pr)
    os.system(cmd_iptables_pr)
    #print cmd_iptables_del_pr
    #print cmd_iptables_pr

# Process additional options
if opt_rp_filter is not None:
    rp_cmd = "/sbin/sysctl net.ipv4.conf.%s.rp_filter=%s" % (vif, opt_rp_filter)
    os.system(rp_cmd)

# OVS datapath
if opt_ovs_dp is not None:
    cmd_ovs_addif = "ovs-dpctl add-if %s %s"%(opt_ovs_dp,vif)
    os.system(cmd_ovs_addif)
