#!/usr/bin/python
# VSYS script to configure per-slice virtual network interfaces from the root slice
#   Thom Haddow - 06/10/09
#
# Gets slice name as argv[1]
# Takes remaining args on stdin:
#   - Interface name (eg [tun|tap]<sliceid>-<n>)
#   - IP address (eg 1.2.3.4)
#   - Netmask (as int, e.g. 24)
#   - Followed by options as name=value pairs

import sys
import pwd
import re
import socket
import struct
import o
vif = arglines[0] # interface name
vip = arglines[1] # IP
vmask = int(arglines[2]) # netmask as int

# Create options list
if len(arglines)>3:
    options = arglines[3:]
else:
    options = []

# Convert network base addr to int format by unpacking as 32bit net-ordered long (!L)
base_int = struct.unpack('!L',socket.inet_aton(base))[0]
mask = int(mask)


### Validate args
# Validate interface name
if len(vif)>16:
    print >>sys.stderr, "Interface name %s invalid"%(vif)
    sys.exit(1)

if re.match(r'(tun|tap)%d-\d+' % sliceid, vif ) is None:
    print >>sys.stderr, "Interface name %s does not match slice id %d."%(vif, sliceid)
    sys.exit(1)



# Validate requested IP and convert to int format.
try:
    vip_int = struct.unpack('!L',socket.inet_aton(vip))[0]
except socket.error:
    print >>sys.stderr, "Invalid IP: %s" % vip
    sys.exit(1)

# Check IP is in netblock
if (vip_int>>(32-mask)) != (base_int>>(32-mask)):
    print >>sys.stderr, "Requested IP %s not in netblock %s/%d" % (vip,base,mask)
    sys.exit(1)

# TODO. Check IP is not in use?

# Validate mask: Check requested mask is sane and within our netblock
if vmask>32 or vmask <8:
    print >>sys.stderr, "Requested netmask /%d is invalid" %(vmask)
    sys.exit(1)
    
if vmask<mask:
    print >>sys.stderr, "Requested netmask /%d larger than allocation /%d" %(vmask, mask)
    sys.exit(1)



### Process options

opt_txqueuelen = None
opt_rp_filter = None
opt_snat = None
opt_ovs_dp = None
opt_pointopoint = None


for optionline in options:
    if len(optionline)==0: continue
    try:
        opt, val = optionline.split('=')
    except:
        print >>sys.stderr, "Bad option line: \"%s\"" % (optionline)
        sys.exit(1)

    if opt=="rp_filter":
        if val=="0":
            opt_rp_filter="0"
        elif val=="1":
            opt_rp_filter="1"
        else:
            print >>sys.stderr, "rp_filter value invalid: \"%s\"" % (val)
            sys.exit(1)

    elif opt=="txqueuelen":
        intval = int(val)
        if intval<1 or intval>10000:
            print >>sys.stderr, "txqueuelen value %s out of range 1-10000" % (val)
            sys.exit(1)
        opt_txqueuelen = intval
    elif opt=="snat":
        intval = int(val)
        if val=="1":
            opt_snat = True
    elif opt=="pointopoint":
        opt_pointopoint = val.strip()
        try:
            socket.inet_aton(opt_pointopoint)
        except socket.error,e:
            print >>sys.stderr, "pointopoint: %s" % (e,)
            sys.exit(1)
    elif opt=="vswitch":
        opt_ovs_dp = val
    else:
        print >>sys.stderr, "Unknown option: \"%s\"" % (opt)
        sys.exit(1)


### Configure interface

cmd_ifconfig = "/sbin/ifconfig %s %s" % (vif, vip)
if opt_pointopoint is None:
    cmd_ifconfig += "/%d" % (vmask,)
else:
    # point-to-point mask
    cmd_ifconfig += " netmask 255.255.255.255"
if opt_txqueuelen is not None:
    cmd_ifconfig += " txqueuelen %d" % (opt_txqueuelen,)
if opt_pointopoint is not None:
    cmd_ifconfig += " pointopoint %s" % (opt_pointopoint,)

os.system(cmd_ifconfig)

# Add iptables rules (Clearing old ones first, if they exist)
cmd_iptables_in = "/sbin/iptables -A INPUT -i %s -m mark -m state --state NEW ! --mark %d -j DROP" % (vif, sliceid)
cmd_iptables_del_in = "/sbin/iptables -D INPUT -i %s -m mark -m state --state NEW ! --mark %d -j DROP 2>/dev/null" % (vif, sliceid)
cmd_iptables_out = "/sbin/iptables -A OUTPUT -o %s -m state --state NEW -m mark ! --mark %d -j DROP" % (vif, sliceid)
cmd_iptables_del_out = "/sbin/iptables -D OUTPUT -o %s -m state --state NEW -m mark ! --mark %d -j DROP 2>/dev/null" % (vif, sliceid)

public_src = os.popen("ifconfig | grep $(ip route | grep default | awk '{print $3}' | awk -F. '{print $1\"[.]\"$2}') | head -1 | awk '{print $2}' | awk -F : '{print $2}'").read().rstrip()
cmd_iptables_pr = "/sbin/iptables -t nat -A POSTROUTING -s %s/%d -j SNAT --to-source %s --random" % (vip, vmask, public_src)
cmd_iptables_del_pr = "/sbin/iptables -t nat -D POSTROUTING -s %s/%d -j SNAT --to-source %s --random > /dev/null 2>&1" % (vip, vmask, public_src)

os.system(cmd_iptables_del_in)
os.system(cmd_iptables_in)
os.system(cmd_iptables_del_out)
os.system(cmd_iptables_out)

# always remove snat rules
# in case there are leftovers from previous calls
os.system(cmd_iptables_del_pr)
if (opt_snat):
    os.system(cmd_iptables_pr)
    #print cmd_iptables_del_pr
    #print cmd_iptables_pr

#if opt_pointopoint and vmask < 32:
#    # Make target vnet masked address
#    p2p_int = struct.unpack('!L', socket.inet_aton(opt_pointopoint))[0]
#    vip_vnet = socket.inet_ntoa(
#        struct.pack('!L', ((p2p_int>>(32-vmask))<<(32-vmask))) )
#
#    cmd_routing_p2p = "/sbin/route add -net %s/%d gw %s dev %s" % (vip_vnet, vmask, opt_pointopoint, vif)
#    print >>sys.stderr, cmd_routing_p2p
#    os.system(cmd_routing_p2p)

# Process additional options
if opt_rp_filter is not None:
    rp_cmd = "/sbin/sysctl net.ipv4.conf.%s.rp_filter=%s" % (vif, opt_rp_filter)
    os.system(rp_cmd)

# OVS datapath
if opt_ovs_dp is not None:
    cmd_ovs_addif = "ovs-dpctl add-if %s %s"%(opt_ovs_dp,vif)
    os.system(cmd_ovs_addif)

